# wechatpay
本分支是微信支付的spring版本。


# 微信支付与安全链接、证书、签名

本仓库是`Java`版本的**微信支付**相关SDK，其中包含了所有微信支付接口的demo。
如果是做支付类型的平台商户，代码有待重构（部分证书信息需要持久化到DB中）。

代码结构图稍后补充。


附：《HTTPS、摘要、加密与签名认证》


文档持续完善中...

# 一、数字摘要

也称为消息摘要，是一个唯一对应一个消息或文本的固定长度的值，由一个单向的Hash函数对消息进行计算而产生，类似指纹。

## 1、消息摘要特点

- 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。MD5有128位，SHA-1有160比特位。
- 只要输入的消息不同，对其进行摘要以后产生的摘要消息也不同，但相同的输入必会产生相同的输出。
- 并不包含原文的完整信息，只能进行正向的信息摘要，无法找到任何与原信息相关的信息。

## 2、摘要算法

### a) MD5

`MD5`即`Message Digest Algorithm5`，摘要长度为128位。

基于Java的MD5算法：

```java
public static byte[] testMD5(String content) throws Exception {
    MessageDigest md = MessageDigest.getInstance("MD5");
    byte[] bytes = md.digest(content.getBytes("utf8"));
    return bytes;
}
```

### b) SHA

`SHA`即`Secure Hash Algorithm`，安全散列算法。1995年修订版称为`SHA-1`，已成为公认的最安全的散列算法之一。`SHA-1`算法生成的摘要信息长度为160位，运行速度比MD5慢，但也更为安全。

基于Java的SHA-1算法：

```java
public static byte[] testSHA1(String content) throws Exception {
    MessageDigest md = MessageDigest.getInstance("SHA-1");
    byte[] bytes = md.digest(content.getBytes("utf8"));
    return bytes;
}
```

## 3、摘要编码

**计算出摘要转换成字符串，可能会生成一些无法显示和网络传输的控制字符，需要对生成的摘要字符串进行编码，通常包括`十六进制编码`和`Base64编码`。**

### a) 十六进制编码

每4位二进制数据对应一位十六进制数据，十六进制由0~9和A~F来进行表示。**Java中没有无符号整型**，每八位有一位符号位，需要将符号位转换为对应的数值，再转换为对应的十六进制。8位二进制可以转换为2位十六进制，不足2位的进行补0。

### b) Base64编码

Base64是一种基于64个可打印字符来表示二进制数据的方法，由于2的6次方等于64，所以每6位为一个单元，对应某个可打印字符，三个字节有24位，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。

**基于Java的Base64算法：[base64加解密](https://github.com/shinnlove/wechatpay/blob/master/src/main/java/com/shinnlove/wechatpay/security/Base64Demo.java)。**

# 二、加密算法

## 1、对称加密

对称加密算法中的密钥只有一个，发送和接收双方都是用这个密钥对数据进行加密和解密。

对称加密算法特点：**算法公开、计算量小、加密速度快、加密效率高**。

**对称加密算法中只有一种密钥，并且是非公开的，所以密钥的保护对于加密信息是否安全至关重要**。

常用的加密算法：`DES算法`、`3DES算法`和`AES算法`。

### a) DES算法

DES，即`Data Encryptin Standard`，1977年颁布的`数据加密标准`。

明文按64位进行分组，密钥长64位，事实上只有56位参与DES运算。

`3DES`是`DES`向`AES`过度的加密算法，使用3条56位的密钥对数据进行3次加密，是DES的一个安全的变形。

### b) 3DES算法

`3DES`使用3条56位的密钥对数据进行3次加密，是`DES`的一个更安全的变形。

[3DES算法Java版](https://github.com/shinnlove/wechatpay/blob/master/src/main/java/com/shinnlove/wechatpay/security/DESDemo.java)。

### c) AES算法

`AES`的全称是`Advanced Encryption Standard`，即高级加密标准，已成为对称加密算法中最流行的算法之一。

[AES算法Java版](https://github.com/shinnlove/wechatpay/blob/master/src/main/java/com/shinnlove/wechatpay/security/DESDemo.java)。

**AES算法支持128、192、256三种密钥长度，但是由于美国对加密软件出口的控制，如果使用192位和256位的密钥，则需要另外下载无政策和司法限制的文件，否则运行时会出现异常。**

## 2、非对称加密

非对称加密算法又称为公开密钥加密算法。公钥与私钥需要配对使用：如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，反之亦然。

**一般需要给你颁发证书的机构会告诉你算法，让你自己生成密钥后再给他公钥，他用公钥加密信息，你用私钥解密信息。私钥不经过他的手，安全性得到保障，确认是你所做的任何事情都无法推脱抵赖、别人也别想伪造你(一般不敢，网警可以查到)。**

**非对称加密即使在获知公钥、加密算法和加密算法源代码的情况下，也无法获得公钥对应的私钥，因此也无法对公钥加密的密文进行解密。**

非对称加密的加解密速度远没有对称加密的加解密速度快，因此广泛使用对称与非对称加密算法结合使用的办法，优缺点互补、达到时间和安全的平衡：使用对称加密较长的文件，用非对称加密密钥或签名。

### a) RSA算法

RSA算法的数论基础：**将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难**。

**基于Java的RSA算法：[RSA公私钥加密](https://github.com/shinnlove/wechatpay/blob/master/src/main/java/com/shinnlove/wechatpay/security/RSADemo.java)。**

首先初始化`KeyPairGenerator`，并生成`KeyPair`，得到`KeyPair`后通过`getPublic`和`getPrivate`分别取得公钥和私钥。为了方便保存可以采用`Base64`编码转换后存入数据库中持久化。

- 使用时需要将String类型的密钥转换为`PublicKey`和`PrivateKey`对象。
- 转换前，先对字符串进行`Base64`解码，**公钥需要转换成`X509EncodedKeySpec`对象**，然后通过`KeyFactory`生成`PublicKey`对象；而**私钥需要先转换成`PKCS8EncodedKeySpec`对象**，再通过`KeyFactory`生成`PrivateKey`对象。
- 加密时，首先获得`RSA`算法的`Cipher`实例，然后传入加密模式`Cipher.ENCRYPT_MODE`和公钥`PublicKey`类的实例进行初始化，通过`doFinal()`方法获得加密的字节流。

**特别注意：使用1024初始化`KeyPairGenerator`，`RSA`加密后的密文长度为1024位，即128个字节，明文最大长度不能超过117个字节。超过117个字节需要使用2048的keysize来初始化；超过245个字节需要使用4096的keysize。keysize位数越高，生成密钥和加解密速度越慢。**

# 三、数字签名

签名认证是非对称加密技术与数字摘要技术的综合运用。

将通信内容的摘要信息使用发送者的私钥进行加密，然后将密文与原文一起传输给信息的接收者，接收者通过发送者的公钥解密被加密的摘要信息，然后使用与发送者相同的摘要算法，对收到的内容采用相同的方式产生摘要串，与解密的摘要串进行对比，如果相同，则说明接收到的内容是完整的，在传输过程中没有受到第三方篡改。

**常见的数字签名算法包括：`MD5withRSA`、`SHA1withRSA`和`SHA256withRSA`。**


算法代码稍后补齐...



## 1、MD5withRSA



## 2、SHA1withRSA



# 四、数字证书

数字证书（Digital Certificate）也称为电子证书，用于标识网络中的用户身份。数字证书集合了多种密码学的加密算法，证书自身带有公钥信息，可以完成相应的加密、解密操作，还拥有自身信息的数字签名，可以鉴别证书的颁发机构，以及证书内容的完整性。

数字证书包含的内容：

- 对象的名称（人、服务器或组织）
- 证书的过期时间
- 证书的颁发机构
- 证书颁发机构对证书信息的数字签名
- 签名算法
- 对象的**公钥**

**数字证书一般采用Base64编码后再进行存储，你会看到熟悉的：——Begin Certificate——和——End Certificate——中间都是Base64编码的字符串。**

## 1、X.509

X.509提供了一种标准的方式，将证书信息规范地存储到了一系列可解析的字段当中，目前X.509 V3是目前最广泛的版本，它所包含的证书字段如下：

| 字段                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| 版本                 | 当前证书X.509标准版本号                                      |
| 序列号               | 证书颁发机构（CA）生成的唯一序列号                           |
| **签名算法**         | 签名使用的签名算法，如SHA1withRSA                            |
| 证书颁发者           |                                                              |
| 有效期               |                                                              |
| 对象名称             |                                                              |
| 对象的公钥信息       |                                                              |
| 发布者ID（可选）     |                                                              |
| 对象ID（可选）       |                                                              |
| 扩展字段             |                                                              |
| 证书颁发机构数字签名 | 证书的颁发机构使用指定的签名算法及颁发机构的私钥对上述所有字段生成数字签名 |

## 2、证书签发

网络用户的数字证书则需要由数字证书认证机构（Certificate Authority, CA）来进行颁发，只有经过CA颁发的证书在网络中才具备可认证性（法律效应）。

三大CA：`VeriSign`、`GeoTrust`和`Thawte`，免费的`Cacert`。

## 3、证书校验

根证书是证书认证机构给自己办法的数字证书，是**证书信任链**的起始点，**安装根证书意味着对这个证书认证机构信任**。大多数操作系统（如windows）都会预先安装一些较为权威的证书认证机构的根证书。

## 4、证书管理

`keytool`是Java的数字证书管理工具，用于数字证书的生成、导入、导出与撤销操作。

a) 构建自签名证书

b) 证书导出

c) 导出CSR

d) CA认证

e) 导入认证数字证书

# 五、摘要认证

摘要认证原理：

- 传递端和接收端都认为HTTP协议的请求参数是无序的，因此客户端与服务端双方需要约定好参数的排序方式
- 当客户端接收到服务端响应后，加上相同的secret或token进行拼接，采用与服务端相同的摘要算法进行摘要
- 摘要认证的安全性取决于secret和token的安全性，因为客户端和服务端都采用相同的secret和token

**当然，在服务端的开发地址中填入白名单IP地址，就可以锁定摘要信息真实性了。**



代码与序列图稍后补全...



## 1、客户端参数摘要生成



## 2、服务端参数摘要校验



## 3、服务端响应摘要生成



## 4、客户端响应摘要校验



# 六、签名认证

签名认证原理：

- 客户端与服务端双方需要约定好参数的排序方式
- 不再是使用secret+token而是直接通过摘要算法来生成数字摘要，并且使用客户端私钥对数字摘要进行加密，将加密的密文传给服务端
- 服务端使用客户端的公钥将接收到的密文进行解密



代码与序列图稍后补全...



## 1、客户端参数签名生成



## 2、服务端参数签名校验



## 3、服务端响应签名生成



## 4、客户端响应签名校验



# 七、HTTPS与SSL

**摘要认证和签名认证虽然能够解决数据完整性和通信两端合法性的问题，但是对于一些较为敏感的信息，如果以明文的形式传递，容易泄露。**

`HTTPS`即`Hypertext Transfer Protocol over Secure Socket Layer`，依托`SSL`协议，HTTPS协议能够确保整个通信过程都是加密的，密钥随机产生，并且能够通过数字证书验证通信双方的身份，以此来保障信息安全。

HTTPS协议在HTTP协议与TCP协议增加了一层安全层，所有请求和响应数据在经过网络传输之前，都会先进性加密，然后再进行传输。

## 1、SSL与TLS

SSL的继任者是TLS协议。

SSL/TLS协议均可以分为两层：

### a) 记录协议



### b) 握手协议



## 2、https部署

`openSSL`的安装与部署。



# 八、OAuth



## 1、授权过程





# 九、附录

扩展阅读材料：

## 1、[签名验签实例](https://os.alipayobjects.com/skylark/6b11af71-1506-45fe-9ae2-720c54979c2a/attach/3517/45a856be2a3b75a2/%2525E6%2525A0%252587%2525E5%252587%252586RSA256withRSA-Demo.txt)

## 2、[XML报文加解密](https://os.alipayobjects.com/skylark/36beefb6-1b0e-4e02-b3a2-7e89b13cdb2e/attach/3517/46195ffaae80194c/http%2525E5%25258D%25258F%2525E8%2525AE%2525AEMAP%2525E6%25258A%2525A5%2525E6%252596%252587.txt)

## 3、[mima处理加解密信息](https://os.alipayobjects.com/skylark/859f4c0a-89fb-432e-9c4c-4503a0d0cfef/attach/3517/7321cc537e87a84f/tcp%2525E5%2525AE%25259A%2525E9%252595%2525BF%2525E6%25258A%2525A5%2525E6%252596%252587mock.txt)


































